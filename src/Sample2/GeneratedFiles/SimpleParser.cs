//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 Simple.g 2012-02-19 09:44:06

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using Sample2;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class SimpleParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "DIGIT", "IDENT", "LETTER", "NUMBER", "WS", "'('", "')'", "'*'", "'+'", "','", "'-'", "'/'", "';'", "'='", "'input'", "'print'"
	};
	public const int EOF=-1;
	public const int DIGIT=4;
	public const int IDENT=5;
	public const int LETTER=6;
	public const int NUMBER=7;
	public const int WS=8;
	public const int T__9=9;
	public const int T__10=10;
	public const int T__11=11;
	public const int T__12=12;
	public const int T__13=13;
	public const int T__14=14;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;
	public const int T__18=18;
	public const int T__19=19;

	public SimpleParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public SimpleParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return SimpleParser.tokenNames; } }
	public override string GrammarFileName { get { return "Simple.g"; } }


		Emitter emitter; 
		
		public SimpleParser(ITokenStream input, Emitter emitter)
				: this(input) 
		{
				this.emitter = emitter;
		}


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// Simple.g:24:1: public program : ( stmt ';' )+ ;
	[GrammarRule("program")]
	public void program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(24, 1);
		try
		{
			// Simple.g:25:2: ( ( stmt ';' )+ )
			DebugEnterAlt(1);
			// Simple.g:25:4: ( stmt ';' )+
			{
			DebugLocation(25, 4);
			// Simple.g:25:4: ( stmt ';' )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==IDENT||(LA1_1>=18 && LA1_1<=19)))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// Simple.g:25:5: stmt ';'
					{
					DebugLocation(25, 5);
					PushFollow(Follow._stmt_in_program40);
					stmt();
					PopFollow();

					DebugLocation(25, 10);
					Match(input,16,Follow._16_in_program42); 

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(26, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return;

	}
	// $ANTLR end "program"

	partial void EnterRule_stmt();
	partial void LeaveRule_stmt();
	// $ANTLR start "stmt"
	// Simple.g:28:1: stmt : ( input_stmt | print_stmt | assign_stmt );
	[GrammarRule("stmt")]
	private void stmt()
	{
		EnterRule_stmt();
		EnterRule("stmt", 2);
		TraceIn("stmt", 2);
		try { DebugEnterRule(GrammarFileName, "stmt");
		DebugLocation(28, 1);
		try
		{
			// Simple.g:29:2: ( input_stmt | print_stmt | assign_stmt )
			int alt2=3;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case 18:
				{
				alt2 = 1;
				}
				break;
			case 19:
				{
				alt2 = 2;
				}
				break;
			case IDENT:
				{
				alt2 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Simple.g:29:4: input_stmt
				{
				DebugLocation(29, 4);
				PushFollow(Follow._input_stmt_in_stmt58);
				input_stmt();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Simple.g:30:5: print_stmt
				{
				DebugLocation(30, 5);
				PushFollow(Follow._print_stmt_in_stmt65);
				print_stmt();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Simple.g:31:5: assign_stmt
				{
				DebugLocation(31, 5);
				PushFollow(Follow._assign_stmt_in_stmt72);
				assign_stmt();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("stmt", 2);
			LeaveRule("stmt", 2);
			LeaveRule_stmt();
		}
		DebugLocation(32, 1);
		} finally { DebugExitRule(GrammarFileName, "stmt"); }
		return;

	}
	// $ANTLR end "stmt"

	partial void EnterRule_assign_stmt();
	partial void LeaveRule_assign_stmt();
	// $ANTLR start "assign_stmt"
	// Simple.g:34:1: assign_stmt : IDENT '=' expression ;
	[GrammarRule("assign_stmt")]
	private void assign_stmt()
	{
		EnterRule_assign_stmt();
		EnterRule("assign_stmt", 3);
		TraceIn("assign_stmt", 3);
		IToken IDENT1 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "assign_stmt");
		DebugLocation(34, 1);
		try
		{
			// Simple.g:35:2: ( IDENT '=' expression )
			DebugEnterAlt(1);
			// Simple.g:35:4: IDENT '=' expression
			{
			DebugLocation(35, 4);
			IDENT1=(IToken)Match(input,IDENT,Follow._IDENT_in_assign_stmt83); 
			DebugLocation(35, 10);
			Match(input,17,Follow._17_in_assign_stmt85); 
			DebugLocation(35, 14);
			PushFollow(Follow._expression_in_assign_stmt87);
			expression();
			PopFollow();

			DebugLocation(35, 25);
			 emitter.AddAssignStatement((IDENT1!=null?IDENT1.Text:null) ); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assign_stmt", 3);
			LeaveRule("assign_stmt", 3);
			LeaveRule_assign_stmt();
		}
		DebugLocation(36, 1);
		} finally { DebugExitRule(GrammarFileName, "assign_stmt"); }
		return;

	}
	// $ANTLR end "assign_stmt"

	partial void EnterRule_print_stmt();
	partial void LeaveRule_print_stmt();
	// $ANTLR start "print_stmt"
	// Simple.g:38:1: print_stmt : 'print' expression ( ',' expression )* ;
	[GrammarRule("print_stmt")]
	private void print_stmt()
	{
		EnterRule_print_stmt();
		EnterRule("print_stmt", 4);
		TraceIn("print_stmt", 4);
		try { DebugEnterRule(GrammarFileName, "print_stmt");
		DebugLocation(38, 106);
		try
		{
			// Simple.g:39:2: ( 'print' expression ( ',' expression )* )
			DebugEnterAlt(1);
			// Simple.g:39:4: 'print' expression ( ',' expression )*
			{
			DebugLocation(39, 4);
			Match(input,19,Follow._19_in_print_stmt100); 
			DebugLocation(39, 12);
			PushFollow(Follow._expression_in_print_stmt102);
			expression();
			PopFollow();

			DebugLocation(39, 23);
			 emitter.AddPrintStatement(); 
			DebugLocation(39, 56);
			// Simple.g:39:56: ( ',' expression )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1==13))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// Simple.g:39:57: ',' expression
					{
					DebugLocation(39, 57);
					Match(input,13,Follow._13_in_print_stmt107); 
					DebugLocation(39, 61);
					PushFollow(Follow._expression_in_print_stmt109);
					expression();
					PopFollow();

					DebugLocation(39, 72);
					 emitter.AddPrintStatement(); 

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("print_stmt", 4);
			LeaveRule("print_stmt", 4);
			LeaveRule_print_stmt();
		}
		DebugLocation(39, 106);
		} finally { DebugExitRule(GrammarFileName, "print_stmt"); }
		return;

	}
	// $ANTLR end "print_stmt"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// Simple.g:41:1: expression : mult (op= ( '+' | '-' ) mult )* ;
	[GrammarRule("expression")]
	private void expression()
	{
		EnterRule_expression();
		EnterRule("expression", 5);
		TraceIn("expression", 5);
		IToken op = default(IToken);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(41, 1);
		try
		{
			// Simple.g:42:2: ( mult (op= ( '+' | '-' ) mult )* )
			DebugEnterAlt(1);
			// Simple.g:42:4: mult (op= ( '+' | '-' ) mult )*
			{
			DebugLocation(42, 4);
			PushFollow(Follow._mult_in_expression123);
			mult();
			PopFollow();

			DebugLocation(42, 9);
			// Simple.g:42:9: (op= ( '+' | '-' ) mult )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==12||LA4_1==14))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// Simple.g:42:11: op= ( '+' | '-' ) mult
					{
					DebugLocation(42, 13);

					op=(IToken)input.LT(1);
					if (input.LA(1)==12||input.LA(1)==14)
					{
						input.Consume();
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(42, 26);
					PushFollow(Follow._mult_in_expression137);
					mult();
					PopFollow();

					DebugLocation(42, 31);
					 emitter.AddOperation((op!=null?op.Text:null)); 

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 5);
			LeaveRule("expression", 5);
			LeaveRule_expression();
		}
		DebugLocation(43, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return;

	}
	// $ANTLR end "expression"

	partial void EnterRule_mult();
	partial void LeaveRule_mult();
	// $ANTLR start "mult"
	// Simple.g:45:1: mult : atom (op= ( '*' | '/' ) atom )* ;
	[GrammarRule("mult")]
	private void mult()
	{
		EnterRule_mult();
		EnterRule("mult", 6);
		TraceIn("mult", 6);
		IToken op = default(IToken);

		try { DebugEnterRule(GrammarFileName, "mult");
		DebugLocation(45, 1);
		try
		{
			// Simple.g:46:2: ( atom (op= ( '*' | '/' ) atom )* )
			DebugEnterAlt(1);
			// Simple.g:46:4: atom (op= ( '*' | '/' ) atom )*
			{
			DebugLocation(46, 4);
			PushFollow(Follow._atom_in_mult155);
			atom();
			PopFollow();

			DebugLocation(46, 9);
			// Simple.g:46:9: (op= ( '*' | '/' ) atom )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==11||LA5_1==15))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Simple.g:46:11: op= ( '*' | '/' ) atom
					{
					DebugLocation(46, 13);

					op=(IToken)input.LT(1);
					if (input.LA(1)==11||input.LA(1)==15)
					{
						input.Consume();
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(46, 27);
					PushFollow(Follow._atom_in_mult170);
					atom();
					PopFollow();

					DebugLocation(46, 32);
					 emitter.AddOperation((op!=null?op.Text:null)); 

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("mult", 6);
			LeaveRule("mult", 6);
			LeaveRule_mult();
		}
		DebugLocation(47, 1);
		} finally { DebugExitRule(GrammarFileName, "mult"); }
		return;

	}
	// $ANTLR end "mult"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Simple.g:49:1: atom : ( IDENT | NUMBER | '(' expression ')' );
	[GrammarRule("atom")]
	private void atom()
	{
		EnterRule_atom();
		EnterRule("atom", 7);
		TraceIn("atom", 7);
		IToken IDENT2 = default(IToken);
		IToken NUMBER3 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(49, 1);
		try
		{
			// Simple.g:50:2: ( IDENT | NUMBER | '(' expression ')' )
			int alt6=3;
			try { DebugEnterDecision(6, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				alt6 = 1;
				}
				break;
			case NUMBER:
				{
				alt6 = 2;
				}
				break;
			case 9:
				{
				alt6 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 6, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Simple.g:50:4: IDENT
				{
				DebugLocation(50, 4);
				IDENT2=(IToken)Match(input,IDENT,Follow._IDENT_in_atom187); 
				DebugLocation(50, 10);
				 emitter.AddLoadID((IDENT2!=null?IDENT2.Text:null)); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Simple.g:51:5: NUMBER
				{
				DebugLocation(51, 5);
				NUMBER3=(IToken)Match(input,NUMBER,Follow._NUMBER_in_atom195); 
				DebugLocation(51, 12);
				 emitter.AddLoadConst((NUMBER3!=null?NUMBER3.Text:null)); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Simple.g:52:5: '(' expression ')'
				{
				DebugLocation(52, 5);
				Match(input,9,Follow._9_in_atom203); 
				DebugLocation(52, 9);
				PushFollow(Follow._expression_in_atom205);
				expression();
				PopFollow();

				DebugLocation(52, 20);
				Match(input,10,Follow._10_in_atom207); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 7);
			LeaveRule("atom", 7);
			LeaveRule_atom();
		}
		DebugLocation(53, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return;

	}
	// $ANTLR end "atom"

	partial void EnterRule_input_stmt();
	partial void LeaveRule_input_stmt();
	// $ANTLR start "input_stmt"
	// Simple.g:55:1: input_stmt : 'input' IDENT ;
	[GrammarRule("input_stmt")]
	private void input_stmt()
	{
		EnterRule_input_stmt();
		EnterRule("input_stmt", 8);
		TraceIn("input_stmt", 8);
		IToken IDENT4 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "input_stmt");
		DebugLocation(55, 1);
		try
		{
			// Simple.g:56:2: ( 'input' IDENT )
			DebugEnterAlt(1);
			// Simple.g:56:4: 'input' IDENT
			{
			DebugLocation(56, 4);
			Match(input,18,Follow._18_in_input_stmt218); 
			DebugLocation(56, 12);
			IDENT4=(IToken)Match(input,IDENT,Follow._IDENT_in_input_stmt220); 
			DebugLocation(56, 18);
			 emitter.AddInputStatement((IDENT4!=null?IDENT4.Text:null) ); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("input_stmt", 8);
			LeaveRule("input_stmt", 8);
			LeaveRule_input_stmt();
		}
		DebugLocation(57, 1);
		} finally { DebugExitRule(GrammarFileName, "input_stmt"); }
		return;

	}
	// $ANTLR end "input_stmt"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _stmt_in_program40 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _16_in_program42 = new BitSet(new ulong[]{0xC0022UL});
		public static readonly BitSet _input_stmt_in_stmt58 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _print_stmt_in_stmt65 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assign_stmt_in_stmt72 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_assign_stmt83 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_assign_stmt85 = new BitSet(new ulong[]{0x2A0UL});
		public static readonly BitSet _expression_in_assign_stmt87 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _19_in_print_stmt100 = new BitSet(new ulong[]{0x2A0UL});
		public static readonly BitSet _expression_in_print_stmt102 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _13_in_print_stmt107 = new BitSet(new ulong[]{0x2A0UL});
		public static readonly BitSet _expression_in_print_stmt109 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _mult_in_expression123 = new BitSet(new ulong[]{0x5002UL});
		public static readonly BitSet _set_in_expression129 = new BitSet(new ulong[]{0x2A0UL});
		public static readonly BitSet _mult_in_expression137 = new BitSet(new ulong[]{0x5002UL});
		public static readonly BitSet _atom_in_mult155 = new BitSet(new ulong[]{0x8802UL});
		public static readonly BitSet _set_in_mult161 = new BitSet(new ulong[]{0x2A0UL});
		public static readonly BitSet _atom_in_mult170 = new BitSet(new ulong[]{0x8802UL});
		public static readonly BitSet _IDENT_in_atom187 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_atom195 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _9_in_atom203 = new BitSet(new ulong[]{0x2A0UL});
		public static readonly BitSet _expression_in_atom205 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _10_in_atom207 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _18_in_input_stmt218 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _IDENT_in_input_stmt220 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
