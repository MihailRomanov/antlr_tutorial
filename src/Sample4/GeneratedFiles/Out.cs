//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 Out.g 2012-03-24 17:47:49

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

using Antlr3.ST;
using Antlr3.ST.Language;
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
public partial class Out : Antlr.Runtime.Tree.TreeParser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "DIGIT", "DIV", "IDENT", "LETTER", "MINUS", "MUL", "NUMBER", "PLUS", "PROGRAM", "STMT_ASSIGN", "STMT_INPUT", "STMT_PRINT", "WS", "'('", "')'", "','", "';'", "'='", "'input'", "'print'"
	};
	public const int EOF=-1;
	public const int DIGIT=4;
	public const int DIV=5;
	public const int IDENT=6;
	public const int LETTER=7;
	public const int MINUS=8;
	public const int MUL=9;
	public const int NUMBER=10;
	public const int PLUS=11;
	public const int PROGRAM=12;
	public const int STMT_ASSIGN=13;
	public const int STMT_INPUT=14;
	public const int STMT_PRINT=15;
	public const int WS=16;
	public const int T__17=17;
	public const int T__18=18;
	public const int T__19=19;
	public const int T__20=20;
	public const int T__21=21;
	public const int T__22=22;
	public const int T__23=23;

	public Out(ITreeNodeStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public Out(ITreeNodeStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}
	private StringTemplateGroup _templateGroup = new StringTemplateGroup("OutTemplates", typeof(AngleBracketTemplateLexer) );

	public StringTemplateGroup TemplateGroup
	{
		get { return _templateGroup; }
		set { _templateGroup = value; }
	}

	public override string[] TokenNames { get { return Out.tokenNames; } }
	public override string GrammarFileName { get { return "Out.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// Out.g:10:1: public program : ^( PROGRAM (t+= stmt )+ ) -> template(st=$t) <<<st; separator=\"\\n\"> >>;
	[GrammarRule("program")]
	public TemplateTreeRuleReturnScope<StringTemplate, CommonTree> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> retval = new TemplateTreeRuleReturnScope<StringTemplate, CommonTree>();
		retval.Start = (CommonTree)input.LT(1);

		List<StringTemplate> list_t = null;
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> t = default(TemplateTreeRuleReturnScope<StringTemplate, CommonTree>);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(10, 45);
		try
		{
			// Out.g:10:9: ( ^( PROGRAM (t+= stmt )+ ) -> template(st=$t) <<<st; separator=\"\\n\"> >>)
			DebugEnterAlt(1);
			// Out.g:10:12: ^( PROGRAM (t+= stmt )+ )
			{
			DebugLocation(10, 12);
			DebugLocation(10, 14);
			Match(input,PROGRAM,Follow._PROGRAM_in_program41); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(10, 22);
			// Out.g:10:22: (t+= stmt )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>=STMT_ASSIGN && LA1_1<=STMT_PRINT)))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// Out.g:10:23: t+= stmt
					{
					DebugLocation(10, 24);
					PushFollow(Follow._stmt_in_program46);
					t=stmt();
					PopFollow();

					if (list_t==null) list_t=new List<StringTemplate>();
					list_t.Add(t.Template);


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			Match(input, TokenTypes.Up, null); 


			// TEMPLATE REWRITE
			// 10:34: -> template(st=$t) <<<st; separator=\"\\n\"> >>
			{
				retval.Template = new StringTemplate(TemplateGroup, "<st; separator=\"\\n\"> ",
				new Dictionary<string, object>() { {"st", list_t} }
			);
			}



			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(11, 45);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_stmt();
	partial void LeaveRule_stmt();
	// $ANTLR start "stmt"
	// Out.g:13:1: stmt : ( input_stmt -> {$input_stmt.st}| print_stmt -> {$print_stmt.st}| assign_stmt -> {$assign_stmt.st});
	[GrammarRule("stmt")]
	private TemplateTreeRuleReturnScope<StringTemplate, CommonTree> stmt()
	{
		EnterRule_stmt();
		EnterRule("stmt", 2);
		TraceIn("stmt", 2);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> retval = new TemplateTreeRuleReturnScope<StringTemplate, CommonTree>();
		retval.Start = (CommonTree)input.LT(1);

		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> input_stmt1 = default(TemplateTreeRuleReturnScope<StringTemplate, CommonTree>);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> print_stmt2 = default(TemplateTreeRuleReturnScope<StringTemplate, CommonTree>);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> assign_stmt3 = default(TemplateTreeRuleReturnScope<StringTemplate, CommonTree>);

		try { DebugEnterRule(GrammarFileName, "stmt");
		DebugLocation(13, 2);
		try
		{
			// Out.g:13:6: ( input_stmt -> {$input_stmt.st}| print_stmt -> {$print_stmt.st}| assign_stmt -> {$assign_stmt.st})
			int alt2=3;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case STMT_INPUT:
				{
				alt2 = 1;
				}
				break;
			case STMT_PRINT:
				{
				alt2 = 2;
				}
				break;
			case STMT_ASSIGN:
				{
				alt2 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// Out.g:13:8: input_stmt
				{
				DebugLocation(13, 8);
				PushFollow(Follow._input_stmt_in_stmt71);
				input_stmt1=input_stmt();
				PopFollow();


				// TEMPLATE REWRITE
				// 13:19: -> {$input_stmt.st}
				{
					retval.Template = (input_stmt1!=null?input_stmt1.Template:null);
				}



				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Out.g:14:5: print_stmt
				{
				DebugLocation(14, 5);
				PushFollow(Follow._print_stmt_in_stmt81);
				print_stmt2=print_stmt();
				PopFollow();


				// TEMPLATE REWRITE
				// 14:17: -> {$print_stmt.st}
				{
					retval.Template = (print_stmt2!=null?print_stmt2.Template:null);
				}



				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Out.g:15:5: assign_stmt
				{
				DebugLocation(15, 5);
				PushFollow(Follow._assign_stmt_in_stmt92);
				assign_stmt3=assign_stmt();
				PopFollow();


				// TEMPLATE REWRITE
				// 15:17: -> {$assign_stmt.st}
				{
					retval.Template = (assign_stmt3!=null?assign_stmt3.Template:null);
				}



				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("stmt", 2);
			LeaveRule("stmt", 2);
			LeaveRule_stmt();
		}
		DebugLocation(16, 2);
		} finally { DebugExitRule(GrammarFileName, "stmt"); }
		return retval;

	}
	// $ANTLR end "stmt"

	partial void EnterRule_assign_stmt();
	partial void LeaveRule_assign_stmt();
	// $ANTLR start "assign_stmt"
	// Out.g:18:1: assign_stmt : ^( STMT_ASSIGN IDENT expression ) -> template(id=$IDENT.Textexp=$expression.st) <<Присваиваем переменной <id> выражение <exp> >>;
	[GrammarRule("assign_stmt")]
	private TemplateTreeRuleReturnScope<StringTemplate, CommonTree> assign_stmt()
	{
		EnterRule_assign_stmt();
		EnterRule("assign_stmt", 3);
		TraceIn("assign_stmt", 3);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> retval = new TemplateTreeRuleReturnScope<StringTemplate, CommonTree>();
		retval.Start = (CommonTree)input.LT(1);

		CommonTree IDENT4 = default(CommonTree);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> expression5 = default(TemplateTreeRuleReturnScope<StringTemplate, CommonTree>);

		try { DebugEnterRule(GrammarFileName, "assign_stmt");
		DebugLocation(18, 1);
		try
		{
			// Out.g:19:2: ( ^( STMT_ASSIGN IDENT expression ) -> template(id=$IDENT.Textexp=$expression.st) <<Присваиваем переменной <id> выражение <exp> >>)
			DebugEnterAlt(1);
			// Out.g:19:4: ^( STMT_ASSIGN IDENT expression )
			{
			DebugLocation(19, 4);
			DebugLocation(19, 6);
			Match(input,STMT_ASSIGN,Follow._STMT_ASSIGN_in_assign_stmt109); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(19, 18);
			IDENT4=(CommonTree)Match(input,IDENT,Follow._IDENT_in_assign_stmt111); 
			DebugLocation(19, 24);
			PushFollow(Follow._expression_in_assign_stmt113);
			expression5=expression();
			PopFollow();


			Match(input, TokenTypes.Up, null); 


			// TEMPLATE REWRITE
			// 19:36: -> template(id=$IDENT.Textexp=$expression.st) <<Присваиваем переменной <id> выражение <exp> >>
			{
				retval.Template = new StringTemplate(TemplateGroup, "Присваиваем переменной <id> выражение <exp> ",
				new Dictionary<string, object>() { {"id", IDENT4.Text}, {"exp", (expression5!=null?expression5.Template:null)} }
			);
			}



			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assign_stmt", 3);
			LeaveRule("assign_stmt", 3);
			LeaveRule_assign_stmt();
		}
		DebugLocation(22, 1);
		} finally { DebugExitRule(GrammarFileName, "assign_stmt"); }
		return retval;

	}
	// $ANTLR end "assign_stmt"

	partial void EnterRule_input_stmt();
	partial void LeaveRule_input_stmt();
	// $ANTLR start "input_stmt"
	// Out.g:24:1: input_stmt : ^( STMT_INPUT IDENT ) -> template(id=$IDENT.Text) <<Вводим значение переменной <id> >>;
	[GrammarRule("input_stmt")]
	private TemplateTreeRuleReturnScope<StringTemplate, CommonTree> input_stmt()
	{
		EnterRule_input_stmt();
		EnterRule("input_stmt", 4);
		TraceIn("input_stmt", 4);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> retval = new TemplateTreeRuleReturnScope<StringTemplate, CommonTree>();
		retval.Start = (CommonTree)input.LT(1);

		CommonTree IDENT6 = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "input_stmt");
		DebugLocation(24, 1);
		try
		{
			// Out.g:25:2: ( ^( STMT_INPUT IDENT ) -> template(id=$IDENT.Text) <<Вводим значение переменной <id> >>)
			DebugEnterAlt(1);
			// Out.g:25:4: ^( STMT_INPUT IDENT )
			{
			DebugLocation(25, 4);
			DebugLocation(25, 6);
			Match(input,STMT_INPUT,Follow._STMT_INPUT_in_input_stmt149); 

			Match(input, TokenTypes.Down, null); 
			DebugLocation(25, 17);
			IDENT6=(CommonTree)Match(input,IDENT,Follow._IDENT_in_input_stmt151); 

			Match(input, TokenTypes.Up, null); 


			// TEMPLATE REWRITE
			// 25:24: -> template(id=$IDENT.Text) <<Вводим значение переменной <id> >>
			{
				retval.Template = new StringTemplate(TemplateGroup, "Вводим значение переменной <id> ",
				new Dictionary<string, object>() { {"id", IDENT6.Text} }
			);
			}



			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("input_stmt", 4);
			LeaveRule("input_stmt", 4);
			LeaveRule_input_stmt();
		}
		DebugLocation(28, 1);
		} finally { DebugExitRule(GrammarFileName, "input_stmt"); }
		return retval;

	}
	// $ANTLR end "input_stmt"

	partial void EnterRule_print_stmt();
	partial void LeaveRule_print_stmt();
	// $ANTLR start "print_stmt"
	// Out.g:30:1: print_stmt : ^( STMT_PRINT (exp+= expression )* ) -> template(exp=$exp) <<Печатаем значения <exp; separator=\", \"> >>;
	[GrammarRule("print_stmt")]
	private TemplateTreeRuleReturnScope<StringTemplate, CommonTree> print_stmt()
	{
		EnterRule_print_stmt();
		EnterRule("print_stmt", 5);
		TraceIn("print_stmt", 5);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> retval = new TemplateTreeRuleReturnScope<StringTemplate, CommonTree>();
		retval.Start = (CommonTree)input.LT(1);

		List<StringTemplate> list_exp = null;
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> exp = default(TemplateTreeRuleReturnScope<StringTemplate, CommonTree>);
		try { DebugEnterRule(GrammarFileName, "print_stmt");
		DebugLocation(30, 1);
		try
		{
			// Out.g:31:2: ( ^( STMT_PRINT (exp+= expression )* ) -> template(exp=$exp) <<Печатаем значения <exp; separator=\", \"> >>)
			DebugEnterAlt(1);
			// Out.g:31:4: ^( STMT_PRINT (exp+= expression )* )
			{
			DebugLocation(31, 4);
			DebugLocation(31, 6);
			Match(input,STMT_PRINT,Follow._STMT_PRINT_in_print_stmt182); 

			if (input.LA(1) == TokenTypes.Down)
			{
				Match(input, TokenTypes.Down, null); 
				DebugLocation(31, 17);
				// Out.g:31:17: (exp+= expression )*
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, false);
					int LA3_1 = input.LA(1);

					if (((LA3_1>=DIV && LA3_1<=IDENT)||(LA3_1>=MINUS && LA3_1<=PLUS)))
					{
						alt3 = 1;
					}


					} finally { DebugExitDecision(3); }
					switch ( alt3 )
					{
					case 1:
						DebugEnterAlt(1);
						// Out.g:31:18: exp+= expression
						{
						DebugLocation(31, 21);
						PushFollow(Follow._expression_in_print_stmt187);
						exp=expression();
						PopFollow();

						if (list_exp==null) list_exp=new List<StringTemplate>();
						list_exp.Add(exp.Template);


						}
						break;

					default:
						goto loop3;
					}
				}

				loop3:
					;

				} finally { DebugExitSubRule(3); }


				Match(input, TokenTypes.Up, null); 
			}


			// TEMPLATE REWRITE
			// 31:37: -> template(exp=$exp) <<Печатаем значения <exp; separator=\", \"> >>
			{
				retval.Template = new StringTemplate(TemplateGroup, "Печатаем значения <exp; separator=\", \"> ",
				new Dictionary<string, object>() { {"exp", list_exp} }
			);
			}



			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("print_stmt", 5);
			LeaveRule("print_stmt", 5);
			LeaveRule_print_stmt();
		}
		DebugLocation(34, 1);
		} finally { DebugExitRule(GrammarFileName, "print_stmt"); }
		return retval;

	}
	// $ANTLR end "print_stmt"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// Out.g:36:1: expression : ( mult -> {$mult.st}| ^( PLUS e1= expression e2= expression ) -> template(e1=$e1.ste2=$e2.st) <<(<e1> + <e2>)>>| ^( MINUS e1= expression e2= expression ) -> template(e1=$e1.ste2=$e2.st) <<(<e1> - <e2>)>>);
	[GrammarRule("expression")]
	private TemplateTreeRuleReturnScope<StringTemplate, CommonTree> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 6);
		TraceIn("expression", 6);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> retval = new TemplateTreeRuleReturnScope<StringTemplate, CommonTree>();
		retval.Start = (CommonTree)input.LT(1);

		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> e1 = default(TemplateTreeRuleReturnScope<StringTemplate, CommonTree>);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> e2 = default(TemplateTreeRuleReturnScope<StringTemplate, CommonTree>);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> mult7 = default(TemplateTreeRuleReturnScope<StringTemplate, CommonTree>);

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(36, 1);
		try
		{
			// Out.g:37:2: ( mult -> {$mult.st}| ^( PLUS e1= expression e2= expression ) -> template(e1=$e1.ste2=$e2.st) <<(<e1> + <e2>)>>| ^( MINUS e1= expression e2= expression ) -> template(e1=$e1.ste2=$e2.st) <<(<e1> - <e2>)>>)
			int alt4=3;
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case DIV:
			case IDENT:
			case MUL:
			case NUMBER:
				{
				alt4 = 1;
				}
				break;
			case PLUS:
				{
				alt4 = 2;
				}
				break;
			case MINUS:
				{
				alt4 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Out.g:37:4: mult
				{
				DebugLocation(37, 4);
				PushFollow(Follow._mult_in_expression219);
				mult7=mult();
				PopFollow();


				// TEMPLATE REWRITE
				// 37:9: -> {$mult.st}
				{
					retval.Template = (mult7!=null?mult7.Template:null);
				}



				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Out.g:38:4: ^( PLUS e1= expression e2= expression )
				{
				DebugLocation(38, 4);
				DebugLocation(38, 6);
				Match(input,PLUS,Follow._PLUS_in_expression229); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(38, 13);
				PushFollow(Follow._expression_in_expression233);
				e1=expression();
				PopFollow();

				DebugLocation(38, 27);
				PushFollow(Follow._expression_in_expression237);
				e2=expression();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				// TEMPLATE REWRITE
				// 38:40: -> template(e1=$e1.ste2=$e2.st) <<(<e1> + <e2>)>>
				{
					retval.Template = new StringTemplate(TemplateGroup, "(<e1> + <e2>)",
					new Dictionary<string, object>() { {"e1", (e1!=null?e1.Template:null)}, {"e2", (e2!=null?e2.Template:null)} }
				);
				}



				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Out.g:41:4: ^( MINUS e1= expression e2= expression )
				{
				DebugLocation(41, 4);
				DebugLocation(41, 6);
				Match(input,MINUS,Follow._MINUS_in_expression264); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(41, 14);
				PushFollow(Follow._expression_in_expression268);
				e1=expression();
				PopFollow();

				DebugLocation(41, 28);
				PushFollow(Follow._expression_in_expression272);
				e2=expression();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				// TEMPLATE REWRITE
				// 41:41: -> template(e1=$e1.ste2=$e2.st) <<(<e1> - <e2>)>>
				{
					retval.Template = new StringTemplate(TemplateGroup, "(<e1> - <e2>)",
					new Dictionary<string, object>() { {"e1", (e1!=null?e1.Template:null)}, {"e2", (e2!=null?e2.Template:null)} }
				);
				}



				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 6);
			LeaveRule("expression", 6);
			LeaveRule_expression();
		}
		DebugLocation(44, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_mult();
	partial void LeaveRule_mult();
	// $ANTLR start "mult"
	// Out.g:46:1: mult : ( atom -> {$atom.st}| ^( MUL e1= mult e2= mult ) -> template(e1=$e1.ste2=$e2.st) <<(<e1> * <e2>)>>| ^( DIV e1= mult e2= mult ) -> template(e1=$e1.ste2=$e2.st) <<(<e1> / <e2>)>>);
	[GrammarRule("mult")]
	private TemplateTreeRuleReturnScope<StringTemplate, CommonTree> mult()
	{
		EnterRule_mult();
		EnterRule("mult", 7);
		TraceIn("mult", 7);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> retval = new TemplateTreeRuleReturnScope<StringTemplate, CommonTree>();
		retval.Start = (CommonTree)input.LT(1);

		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> e1 = default(TemplateTreeRuleReturnScope<StringTemplate, CommonTree>);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> e2 = default(TemplateTreeRuleReturnScope<StringTemplate, CommonTree>);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> atom8 = default(TemplateTreeRuleReturnScope<StringTemplate, CommonTree>);

		try { DebugEnterRule(GrammarFileName, "mult");
		DebugLocation(46, 1);
		try
		{
			// Out.g:47:2: ( atom -> {$atom.st}| ^( MUL e1= mult e2= mult ) -> template(e1=$e1.ste2=$e2.st) <<(<e1> * <e2>)>>| ^( DIV e1= mult e2= mult ) -> template(e1=$e1.ste2=$e2.st) <<(<e1> / <e2>)>>)
			int alt5=3;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case IDENT:
			case NUMBER:
				{
				alt5 = 1;
				}
				break;
			case MUL:
				{
				alt5 = 2;
				}
				break;
			case DIV:
				{
				alt5 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Out.g:47:4: atom
				{
				DebugLocation(47, 4);
				PushFollow(Follow._atom_in_mult305);
				atom8=atom();
				PopFollow();


				// TEMPLATE REWRITE
				// 47:9: -> {$atom.st}
				{
					retval.Template = (atom8!=null?atom8.Template:null);
				}



				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Out.g:48:4: ^( MUL e1= mult e2= mult )
				{
				DebugLocation(48, 4);
				DebugLocation(48, 6);
				Match(input,MUL,Follow._MUL_in_mult315); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(48, 12);
				PushFollow(Follow._mult_in_mult319);
				e1=mult();
				PopFollow();

				DebugLocation(48, 20);
				PushFollow(Follow._mult_in_mult323);
				e2=mult();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				// TEMPLATE REWRITE
				// 48:27: -> template(e1=$e1.ste2=$e2.st) <<(<e1> * <e2>)>>
				{
					retval.Template = new StringTemplate(TemplateGroup, "(<e1> * <e2>)",
					new Dictionary<string, object>() { {"e1", (e1!=null?e1.Template:null)}, {"e2", (e2!=null?e2.Template:null)} }
				);
				}



				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Out.g:51:4: ^( DIV e1= mult e2= mult )
				{
				DebugLocation(51, 4);
				DebugLocation(51, 6);
				Match(input,DIV,Follow._DIV_in_mult350); 

				Match(input, TokenTypes.Down, null); 
				DebugLocation(51, 12);
				PushFollow(Follow._mult_in_mult354);
				e1=mult();
				PopFollow();

				DebugLocation(51, 20);
				PushFollow(Follow._mult_in_mult358);
				e2=mult();
				PopFollow();


				Match(input, TokenTypes.Up, null); 


				// TEMPLATE REWRITE
				// 51:27: -> template(e1=$e1.ste2=$e2.st) <<(<e1> / <e2>)>>
				{
					retval.Template = new StringTemplate(TemplateGroup, "(<e1> / <e2>)",
					new Dictionary<string, object>() { {"e1", (e1!=null?e1.Template:null)}, {"e2", (e2!=null?e2.Template:null)} }
				);
				}



				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("mult", 7);
			LeaveRule("mult", 7);
			LeaveRule_mult();
		}
		DebugLocation(54, 1);
		} finally { DebugExitRule(GrammarFileName, "mult"); }
		return retval;

	}
	// $ANTLR end "mult"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// Out.g:56:1: atom : ( IDENT -> {%{$IDENT.Text}}| NUMBER -> {%{$NUMBER.Text}});
	[GrammarRule("atom")]
	private TemplateTreeRuleReturnScope<StringTemplate, CommonTree> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 8);
		TraceIn("atom", 8);
		TemplateTreeRuleReturnScope<StringTemplate, CommonTree> retval = new TemplateTreeRuleReturnScope<StringTemplate, CommonTree>();
		retval.Start = (CommonTree)input.LT(1);

		CommonTree IDENT9 = default(CommonTree);
		CommonTree NUMBER10 = default(CommonTree);

		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(56, 1);
		try
		{
			// Out.g:57:2: ( IDENT -> {%{$IDENT.Text}}| NUMBER -> {%{$NUMBER.Text}})
			int alt6=2;
			try { DebugEnterDecision(6, false);
			int LA6_1 = input.LA(1);

			if ((LA6_1==IDENT))
			{
				alt6 = 1;
			}
			else if ((LA6_1==NUMBER))
			{
				alt6 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 6, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// Out.g:57:4: IDENT
				{
				DebugLocation(57, 4);
				IDENT9=(CommonTree)Match(input,IDENT,Follow._IDENT_in_atom391); 

				// TEMPLATE REWRITE
				// 57:10: -> {%{$IDENT.Text}}
				{
					retval.Template = new StringTemplate(TemplateGroup,IDENT9.Text);
				}



				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Out.g:58:5: NUMBER
				{
				DebugLocation(58, 5);
				NUMBER10=(CommonTree)Match(input,NUMBER,Follow._NUMBER_in_atom401); 

				// TEMPLATE REWRITE
				// 58:12: -> {%{$NUMBER.Text}}
				{
					retval.Template = new StringTemplate(TemplateGroup,NUMBER10.Text);
				}



				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("atom", 8);
			LeaveRule("atom", 8);
			LeaveRule_atom();
		}
		DebugLocation(59, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _PROGRAM_in_program41 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _stmt_in_program46 = new BitSet(new ulong[]{0xE008UL});
		public static readonly BitSet _input_stmt_in_stmt71 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _print_stmt_in_stmt81 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assign_stmt_in_stmt92 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STMT_ASSIGN_in_assign_stmt109 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENT_in_assign_stmt111 = new BitSet(new ulong[]{0xF60UL});
		public static readonly BitSet _expression_in_assign_stmt113 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _STMT_INPUT_in_input_stmt149 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _IDENT_in_input_stmt151 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _STMT_PRINT_in_print_stmt182 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_print_stmt187 = new BitSet(new ulong[]{0xF68UL});
		public static readonly BitSet _mult_in_expression219 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_expression229 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression233 = new BitSet(new ulong[]{0xF60UL});
		public static readonly BitSet _expression_in_expression237 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _MINUS_in_expression264 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _expression_in_expression268 = new BitSet(new ulong[]{0xF60UL});
		public static readonly BitSet _expression_in_expression272 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _atom_in_mult305 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MUL_in_mult315 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _mult_in_mult319 = new BitSet(new ulong[]{0x660UL});
		public static readonly BitSet _mult_in_mult323 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _DIV_in_mult350 = new BitSet(new ulong[]{0x4UL});
		public static readonly BitSet _mult_in_mult354 = new BitSet(new ulong[]{0x660UL});
		public static readonly BitSet _mult_in_mult358 = new BitSet(new ulong[]{0x8UL});
		public static readonly BitSet _IDENT_in_atom391 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUMBER_in_atom401 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
